// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	"istio.io/istio/pilot/pkg/model"
	"istio.io/istio/pkg/config/host"
	"istio.io/istio/pkg/config/labels"
)

type ServiceDiscovery struct {
	ServicesStub        func() ([]*model.Service, error)
	servicesMutex       sync.RWMutex
	servicesArgsForCall []struct{}
	servicesReturns     struct {
		result1 []*model.Service
		result2 error
	}
	servicesReturnsOnCall map[int]struct {
		result1 []*model.Service
		result2 error
	}
	GetServiceStub        func(hostname host.Name) (*model.Service, error)
	getServiceMutex       sync.RWMutex
	getServiceArgsForCall []struct {
		hostname host.Name
	}
	getServiceReturns struct {
		result1 *model.Service
		result2 error
	}
	getServiceReturnsOnCall map[int]struct {
		result1 *model.Service
		result2 error
	}
	InstancesByPortStub        func(svc *model.Service, servicePort int, labels labels.Collection) ([]*model.ServiceInstance, error)
	instancesByPortMutex       sync.RWMutex
	instancesByPortArgsForCall []struct {
		svc         *model.Service
		servicePort int
		labels      labels.Collection
	}
	instancesByPortReturns struct {
		result1 []*model.ServiceInstance
		result2 error
	}
	instancesByPortReturnsOnCall map[int]struct {
		result1 []*model.ServiceInstance
		result2 error
	}
	GetProxyServiceInstancesStub        func(*model.Proxy) ([]*model.ServiceInstance, error)
	getProxyServiceInstancesMutex       sync.RWMutex
	getProxyServiceInstancesArgsForCall []struct {
		arg1 *model.Proxy
	}
	getProxyServiceInstancesReturns struct {
		result1 []*model.ServiceInstance
		result2 error
	}
	getProxyServiceInstancesReturnsOnCall map[int]struct {
		result1 []*model.ServiceInstance
		result2 error
	}
	GetProxyWorkloadLabelsStub        func(*model.Proxy) (labels.Collection, error)
	getProxyWorkloadLabelsMutex       sync.RWMutex
	getProxyWorkloadLabelsArgsForCall []struct {
		arg1 *model.Proxy
	}
	getProxyWorkloadLabelsReturns struct {
		result1 labels.Collection
		result2 error
	}
	getProxyWorkloadLabelsReturnsOnCall map[int]struct {
		result1 labels.Collection
		result2 error
	}
	ManagementPortsStub        func(addr string) model.PortList
	managementPortsMutex       sync.RWMutex
	managementPortsArgsForCall []struct {
		addr string
	}
	managementPortsReturns struct {
		result1 model.PortList
	}
	managementPortsReturnsOnCall map[int]struct {
		result1 model.PortList
	}
	WorkloadHealthCheckInfoStub        func(addr string) model.ProbeList
	workloadHealthCheckInfoMutex       sync.RWMutex
	workloadHealthCheckInfoArgsForCall []struct {
		addr string
	}
	workloadHealthCheckInfoReturns struct {
		result1 model.ProbeList
	}
	workloadHealthCheckInfoReturnsOnCall map[int]struct {
		result1 model.ProbeList
	}
	GetIstioServiceAccountsStub        func(svc *model.Service, ports []int) []string
	getIstioServiceAccountsMutex       sync.RWMutex
	getIstioServiceAccountsArgsForCall []struct {
		svc   *model.Service
		ports []int
	}
	getIstioServiceAccountsReturns struct {
		result1 []string
	}
	getIstioServiceAccountsReturnsOnCall map[int]struct {
		result1 []string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *ServiceDiscovery) Services() ([]*model.Service, error) {
	fake.servicesMutex.Lock()
	ret, specificReturn := fake.servicesReturnsOnCall[len(fake.servicesArgsForCall)]
	fake.servicesArgsForCall = append(fake.servicesArgsForCall, struct{}{})
	fake.recordInvocation("Services", []interface{}{})
	fake.servicesMutex.Unlock()
	if fake.ServicesStub != nil {
		return fake.ServicesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.servicesReturns.result1, fake.servicesReturns.result2
}

func (fake *ServiceDiscovery) ServicesCallCount() int {
	fake.servicesMutex.RLock()
	defer fake.servicesMutex.RUnlock()
	return len(fake.servicesArgsForCall)
}

func (fake *ServiceDiscovery) ServicesReturns(result1 []*model.Service, result2 error) {
	fake.ServicesStub = nil
	fake.servicesReturns = struct {
		result1 []*model.Service
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) ServicesReturnsOnCall(i int, result1 []*model.Service, result2 error) {
	fake.ServicesStub = nil
	if fake.servicesReturnsOnCall == nil {
		fake.servicesReturnsOnCall = make(map[int]struct {
			result1 []*model.Service
			result2 error
		})
	}
	fake.servicesReturnsOnCall[i] = struct {
		result1 []*model.Service
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) GetService(hostname host.Name) (*model.Service, error) {
	fake.getServiceMutex.Lock()
	ret, specificReturn := fake.getServiceReturnsOnCall[len(fake.getServiceArgsForCall)]
	fake.getServiceArgsForCall = append(fake.getServiceArgsForCall, struct {
		hostname host.Name
	}{hostname})
	fake.recordInvocation("GetService", []interface{}{hostname})
	fake.getServiceMutex.Unlock()
	if fake.GetServiceStub != nil {
		return fake.GetServiceStub(hostname)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getServiceReturns.result1, fake.getServiceReturns.result2
}

func (fake *ServiceDiscovery) GetServiceCallCount() int {
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	return len(fake.getServiceArgsForCall)
}

func (fake *ServiceDiscovery) GetServiceArgsForCall(i int) host.Name {
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	return fake.getServiceArgsForCall[i].hostname
}

func (fake *ServiceDiscovery) GetServiceReturns(result1 *model.Service, result2 error) {
	fake.GetServiceStub = nil
	fake.getServiceReturns = struct {
		result1 *model.Service
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) GetServiceReturnsOnCall(i int, result1 *model.Service, result2 error) {
	fake.GetServiceStub = nil
	if fake.getServiceReturnsOnCall == nil {
		fake.getServiceReturnsOnCall = make(map[int]struct {
			result1 *model.Service
			result2 error
		})
	}
	fake.getServiceReturnsOnCall[i] = struct {
		result1 *model.Service
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) InstancesByPort(svc *model.Service, servicePort int, l labels.Collection) ([]*model.ServiceInstance, error) {
	fake.instancesByPortMutex.Lock()
	ret, specificReturn := fake.instancesByPortReturnsOnCall[len(fake.instancesByPortArgsForCall)]
	fake.instancesByPortArgsForCall = append(fake.instancesByPortArgsForCall, struct {
		svc         *model.Service
		servicePort int
		labels      labels.Collection
	}{svc, servicePort, l})
	fake.recordInvocation("InstancesByPort", []interface{}{svc, servicePort, l})
	fake.instancesByPortMutex.Unlock()
	if fake.InstancesByPortStub != nil {
		return fake.InstancesByPortStub(svc, servicePort, l)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.instancesByPortReturns.result1, fake.instancesByPortReturns.result2
}

func (fake *ServiceDiscovery) InstancesByPortCallCount() int {
	fake.instancesByPortMutex.RLock()
	defer fake.instancesByPortMutex.RUnlock()
	return len(fake.instancesByPortArgsForCall)
}

func (fake *ServiceDiscovery) InstancesByPortArgsForCall(i int) (*model.Service, int, labels.Collection) {
	fake.instancesByPortMutex.RLock()
	defer fake.instancesByPortMutex.RUnlock()
	return fake.instancesByPortArgsForCall[i].svc, fake.instancesByPortArgsForCall[i].servicePort, fake.instancesByPortArgsForCall[i].labels
}

func (fake *ServiceDiscovery) InstancesByPortReturns(result1 []*model.ServiceInstance, result2 error) {
	fake.InstancesByPortStub = nil
	fake.instancesByPortReturns = struct {
		result1 []*model.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) InstancesByPortReturnsOnCall(i int, result1 []*model.ServiceInstance, result2 error) {
	fake.InstancesByPortStub = nil
	if fake.instancesByPortReturnsOnCall == nil {
		fake.instancesByPortReturnsOnCall = make(map[int]struct {
			result1 []*model.ServiceInstance
			result2 error
		})
	}
	fake.instancesByPortReturnsOnCall[i] = struct {
		result1 []*model.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) GetProxyServiceInstances(arg1 *model.Proxy) ([]*model.ServiceInstance, error) {
	fake.getProxyServiceInstancesMutex.Lock()
	ret, specificReturn := fake.getProxyServiceInstancesReturnsOnCall[len(fake.getProxyServiceInstancesArgsForCall)]
	fake.getProxyServiceInstancesArgsForCall = append(fake.getProxyServiceInstancesArgsForCall, struct {
		arg1 *model.Proxy
	}{arg1})
	fake.recordInvocation("GetProxyServiceInstances", []interface{}{arg1})
	fake.getProxyServiceInstancesMutex.Unlock()
	if fake.GetProxyServiceInstancesStub != nil {
		return fake.GetProxyServiceInstancesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getProxyServiceInstancesReturns.result1, fake.getProxyServiceInstancesReturns.result2
}

func (fake *ServiceDiscovery) GetProxyServiceInstancesCallCount() int {
	fake.getProxyServiceInstancesMutex.RLock()
	defer fake.getProxyServiceInstancesMutex.RUnlock()
	return len(fake.getProxyServiceInstancesArgsForCall)
}

func (fake *ServiceDiscovery) GetProxyServiceInstancesArgsForCall(i int) *model.Proxy {
	fake.getProxyServiceInstancesMutex.RLock()
	defer fake.getProxyServiceInstancesMutex.RUnlock()
	return fake.getProxyServiceInstancesArgsForCall[i].arg1
}

func (fake *ServiceDiscovery) GetProxyServiceInstancesReturns(result1 []*model.ServiceInstance, result2 error) {
	fake.GetProxyServiceInstancesStub = nil
	fake.getProxyServiceInstancesReturns = struct {
		result1 []*model.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) GetProxyServiceInstancesReturnsOnCall(i int, result1 []*model.ServiceInstance, result2 error) {
	fake.GetProxyServiceInstancesStub = nil
	if fake.getProxyServiceInstancesReturnsOnCall == nil {
		fake.getProxyServiceInstancesReturnsOnCall = make(map[int]struct {
			result1 []*model.ServiceInstance
			result2 error
		})
	}
	fake.getProxyServiceInstancesReturnsOnCall[i] = struct {
		result1 []*model.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) GetProxyWorkloadLabels(arg1 *model.Proxy) (labels.Collection, error) {
	fake.getProxyWorkloadLabelsMutex.Lock()
	ret, specificReturn := fake.getProxyWorkloadLabelsReturnsOnCall[len(fake.getProxyWorkloadLabelsArgsForCall)]
	fake.getProxyWorkloadLabelsArgsForCall = append(fake.getProxyWorkloadLabelsArgsForCall, struct {
		arg1 *model.Proxy
	}{arg1})
	fake.recordInvocation("GetProxyWorkloadLabels", []interface{}{arg1})
	fake.getProxyWorkloadLabelsMutex.Unlock()
	if fake.GetProxyWorkloadLabelsStub != nil {
		return fake.GetProxyWorkloadLabelsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getProxyWorkloadLabelsReturns.result1, fake.getProxyWorkloadLabelsReturns.result2
}

func (fake *ServiceDiscovery) GetProxyWorkloadLabelsCallCount() int {
	fake.getProxyWorkloadLabelsMutex.RLock()
	defer fake.getProxyWorkloadLabelsMutex.RUnlock()
	return len(fake.getProxyWorkloadLabelsArgsForCall)
}

func (fake *ServiceDiscovery) GetProxyWorkloadLabelsArgsForCall(i int) *model.Proxy {
	fake.getProxyWorkloadLabelsMutex.RLock()
	defer fake.getProxyWorkloadLabelsMutex.RUnlock()
	return fake.getProxyWorkloadLabelsArgsForCall[i].arg1
}

func (fake *ServiceDiscovery) GetProxyWorkloadLabelsReturns(result1 labels.Collection, result2 error) {
	fake.GetProxyWorkloadLabelsStub = nil
	fake.getProxyWorkloadLabelsReturns = struct {
		result1 labels.Collection
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) GetProxyWorkloadLabelsReturnsOnCall(i int, result1 labels.Collection, result2 error) {
	fake.GetProxyWorkloadLabelsStub = nil
	if fake.getProxyWorkloadLabelsReturnsOnCall == nil {
		fake.getProxyWorkloadLabelsReturnsOnCall = make(map[int]struct {
			result1 labels.Collection
			result2 error
		})
	}
	fake.getProxyWorkloadLabelsReturnsOnCall[i] = struct {
		result1 labels.Collection
		result2 error
	}{result1, result2}
}

func (fake *ServiceDiscovery) ManagementPorts(addr string) model.PortList {
	fake.managementPortsMutex.Lock()
	ret, specificReturn := fake.managementPortsReturnsOnCall[len(fake.managementPortsArgsForCall)]
	fake.managementPortsArgsForCall = append(fake.managementPortsArgsForCall, struct {
		addr string
	}{addr})
	fake.recordInvocation("ManagementPorts", []interface{}{addr})
	fake.managementPortsMutex.Unlock()
	if fake.ManagementPortsStub != nil {
		return fake.ManagementPortsStub(addr)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.managementPortsReturns.result1
}

func (fake *ServiceDiscovery) ManagementPortsCallCount() int {
	fake.managementPortsMutex.RLock()
	defer fake.managementPortsMutex.RUnlock()
	return len(fake.managementPortsArgsForCall)
}

func (fake *ServiceDiscovery) ManagementPortsArgsForCall(i int) string {
	fake.managementPortsMutex.RLock()
	defer fake.managementPortsMutex.RUnlock()
	return fake.managementPortsArgsForCall[i].addr
}

func (fake *ServiceDiscovery) ManagementPortsReturns(result1 model.PortList) {
	fake.ManagementPortsStub = nil
	fake.managementPortsReturns = struct {
		result1 model.PortList
	}{result1}
}

func (fake *ServiceDiscovery) ManagementPortsReturnsOnCall(i int, result1 model.PortList) {
	fake.ManagementPortsStub = nil
	if fake.managementPortsReturnsOnCall == nil {
		fake.managementPortsReturnsOnCall = make(map[int]struct {
			result1 model.PortList
		})
	}
	fake.managementPortsReturnsOnCall[i] = struct {
		result1 model.PortList
	}{result1}
}

func (fake *ServiceDiscovery) WorkloadHealthCheckInfo(addr string) model.ProbeList {
	fake.workloadHealthCheckInfoMutex.Lock()
	ret, specificReturn := fake.workloadHealthCheckInfoReturnsOnCall[len(fake.workloadHealthCheckInfoArgsForCall)]
	fake.workloadHealthCheckInfoArgsForCall = append(fake.workloadHealthCheckInfoArgsForCall, struct {
		addr string
	}{addr})
	fake.recordInvocation("WorkloadHealthCheckInfo", []interface{}{addr})
	fake.workloadHealthCheckInfoMutex.Unlock()
	if fake.WorkloadHealthCheckInfoStub != nil {
		return fake.WorkloadHealthCheckInfoStub(addr)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.workloadHealthCheckInfoReturns.result1
}

func (fake *ServiceDiscovery) WorkloadHealthCheckInfoCallCount() int {
	fake.workloadHealthCheckInfoMutex.RLock()
	defer fake.workloadHealthCheckInfoMutex.RUnlock()
	return len(fake.workloadHealthCheckInfoArgsForCall)
}

func (fake *ServiceDiscovery) WorkloadHealthCheckInfoArgsForCall(i int) string {
	fake.workloadHealthCheckInfoMutex.RLock()
	defer fake.workloadHealthCheckInfoMutex.RUnlock()
	return fake.workloadHealthCheckInfoArgsForCall[i].addr
}

func (fake *ServiceDiscovery) WorkloadHealthCheckInfoReturns(result1 model.ProbeList) {
	fake.WorkloadHealthCheckInfoStub = nil
	fake.workloadHealthCheckInfoReturns = struct {
		result1 model.ProbeList
	}{result1}
}

func (fake *ServiceDiscovery) WorkloadHealthCheckInfoReturnsOnCall(i int, result1 model.ProbeList) {
	fake.WorkloadHealthCheckInfoStub = nil
	if fake.workloadHealthCheckInfoReturnsOnCall == nil {
		fake.workloadHealthCheckInfoReturnsOnCall = make(map[int]struct {
			result1 model.ProbeList
		})
	}
	fake.workloadHealthCheckInfoReturnsOnCall[i] = struct {
		result1 model.ProbeList
	}{result1}
}

func (fake *ServiceDiscovery) GetIstioServiceAccounts(svc *model.Service, ports []int) []string {
	var portsCopy []int
	if ports != nil {
		portsCopy = make([]int, len(ports))
		copy(portsCopy, ports)
	}
	fake.getIstioServiceAccountsMutex.Lock()
	ret, specificReturn := fake.getIstioServiceAccountsReturnsOnCall[len(fake.getIstioServiceAccountsArgsForCall)]
	fake.getIstioServiceAccountsArgsForCall = append(fake.getIstioServiceAccountsArgsForCall, struct {
		svc   *model.Service
		ports []int
	}{svc, portsCopy})
	fake.recordInvocation("GetIstioServiceAccounts", []interface{}{svc, portsCopy})
	fake.getIstioServiceAccountsMutex.Unlock()
	if fake.GetIstioServiceAccountsStub != nil {
		return fake.GetIstioServiceAccountsStub(svc, ports)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getIstioServiceAccountsReturns.result1
}

func (fake *ServiceDiscovery) GetIstioServiceAccountsCallCount() int {
	fake.getIstioServiceAccountsMutex.RLock()
	defer fake.getIstioServiceAccountsMutex.RUnlock()
	return len(fake.getIstioServiceAccountsArgsForCall)
}

func (fake *ServiceDiscovery) GetIstioServiceAccountsArgsForCall(i int) (*model.Service, []int) {
	fake.getIstioServiceAccountsMutex.RLock()
	defer fake.getIstioServiceAccountsMutex.RUnlock()
	return fake.getIstioServiceAccountsArgsForCall[i].svc, fake.getIstioServiceAccountsArgsForCall[i].ports
}

func (fake *ServiceDiscovery) GetIstioServiceAccountsReturns(result1 []string) {
	fake.GetIstioServiceAccountsStub = nil
	fake.getIstioServiceAccountsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *ServiceDiscovery) GetIstioServiceAccountsReturnsOnCall(i int, result1 []string) {
	fake.GetIstioServiceAccountsStub = nil
	if fake.getIstioServiceAccountsReturnsOnCall == nil {
		fake.getIstioServiceAccountsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.getIstioServiceAccountsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *ServiceDiscovery) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.servicesMutex.RLock()
	defer fake.servicesMutex.RUnlock()
	fake.getServiceMutex.RLock()
	defer fake.getServiceMutex.RUnlock()
	fake.instancesByPortMutex.RLock()
	defer fake.instancesByPortMutex.RUnlock()
	fake.getProxyServiceInstancesMutex.RLock()
	defer fake.getProxyServiceInstancesMutex.RUnlock()
	fake.getProxyWorkloadLabelsMutex.RLock()
	defer fake.getProxyWorkloadLabelsMutex.RUnlock()
	fake.managementPortsMutex.RLock()
	defer fake.managementPortsMutex.RUnlock()
	fake.workloadHealthCheckInfoMutex.RLock()
	defer fake.workloadHealthCheckInfoMutex.RUnlock()
	fake.getIstioServiceAccountsMutex.RLock()
	defer fake.getIstioServiceAccountsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *ServiceDiscovery) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ model.ServiceDiscovery = new(ServiceDiscovery)
